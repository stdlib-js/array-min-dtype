{"version":3,"file":"index.mjs","sources":["../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isInteger from '@stdlib/math-base-assert-is-integer' ;\nimport isNegativeZero from '@stdlib/math-base-assert-is-negative-zero' ;\nimport isComplexLike from '@stdlib/assert-is-complex-like' ;\nimport PINF from '@stdlib/constants-float64-pinf' ;\nimport NINF from '@stdlib/constants-float64-ninf' ;\nimport FLOAT32_SMALLEST_SUBNORMAL from '@stdlib/constants-float32-smallest-subnormal' ; // eslint-disable-line id-length\nimport FLOAT32_MAX_SAFE_INTEGER from '@stdlib/constants-float32-max-safe-integer' ;\nimport FLOAT32_MIN_SAFE_INTEGER from '@stdlib/constants-float32-min-safe-integer' ;\nimport INT8_MIN from '@stdlib/constants-int8-min' ;\nimport INT16_MIN from '@stdlib/constants-int16-min' ;\nimport INT32_MIN from '@stdlib/constants-int32-min' ;\nimport UINT8_MAX from '@stdlib/constants-uint8-max' ;\nimport UINT16_MAX from '@stdlib/constants-uint16-max' ;\nimport UINT32_MAX from '@stdlib/constants-uint32-max' ;\n\n\n// FUNCTIONS //\n\n/**\n* Returns the minimum floating-point array data type of the closest \"kind\" necessary for storing a provided scalar.\n*\n* @private\n* @param {number} value - real value\n* @returns {string} array data type\n*/\nfunction minFloatDataType( value ) {\n\tif ( value !== value || value === PINF || value === NINF ) {\n\t\treturn 'float32';\n\t}\n\tif ( isInteger( value ) ) {\n\t\tif ( value >= FLOAT32_MIN_SAFE_INTEGER && value <= FLOAT32_MAX_SAFE_INTEGER ) { // eslint-disable-line max-len\n\t\t\treturn 'float32';\n\t\t}\n\t\treturn 'float64';\n\t}\n\t// Assume that if we are provided a tiny value, we don't want to underflow to zero by storing as `float32`...\n\tif (\n\t\tvalue > -FLOAT32_SMALLEST_SUBNORMAL &&\n\t\tvalue < FLOAT32_SMALLEST_SUBNORMAL\n\t) {\n\t\treturn 'float64';\n\t}\n\t// Any number which reaches this point is less than the maximum single-precision floating-point number, as floating-point format supports a limited number of decimals (e.g., (1.0+EPS)*10**15 => 1000000000000000.2, which is less than ~3.4e38)...\n\treturn 'float32';\n}\n\n\n// MAIN //\n\n/**\n* Returns the minimum array data type of the closest \"kind\" necessary for storing a provided scalar value.\n*\n* @param {*} value - scalar value\n* @returns {string} array data type\n*\n* @example\n* var dt = minDataType( 3.141592653589793 );\n* // returns 'float32'\n*\n* @example\n* var dt = minDataType( 3 );\n* // returns 'uint8'\n*/\nfunction minDataType( value ) {\n\tif ( typeof value !== 'number' ) {\n\t\tif ( isComplexLike( value ) ) {\n\t\t\tif ( minFloatDataType( value.re ) === 'float64' || minFloatDataType( value.im ) === 'float64' ) {\n\t\t\t\treturn 'complex128';\n\t\t\t}\n\t\t\treturn 'complex64';\n\t\t}\n\t\treturn 'generic';\n\t}\n\tif ( value !== value || value === PINF || value === NINF ) {\n\t\treturn 'float32';\n\t}\n\tif ( isInteger( value ) ) {\n\t\tif ( value === 0 && isNegativeZero( value ) ) {\n\t\t\treturn 'float32';\n\t\t}\n\t\tif ( value < 0 ) {\n\t\t\tif ( value >= INT8_MIN ) {\n\t\t\t\treturn 'int8';\n\t\t\t}\n\t\t\tif ( value >= INT16_MIN ) {\n\t\t\t\treturn 'int16';\n\t\t\t}\n\t\t\tif ( value >= INT32_MIN ) {\n\t\t\t\treturn 'int32';\n\t\t\t}\n\t\t\treturn 'float64';\n\t\t}\n\t\tif ( value <= UINT8_MAX ) {\n\t\t\treturn 'uint8';\n\t\t}\n\t\tif ( value <= UINT16_MAX ) {\n\t\t\treturn 'uint16';\n\t\t}\n\t\tif ( value <= UINT32_MAX ) {\n\t\t\treturn 'uint32';\n\t\t}\n\t\treturn 'float64';\n\t}\n\t// Assume that if we are provided a tiny value, we don't want to underflow to zero by storing as `float32`...\n\tif (\n\t\tvalue > -FLOAT32_SMALLEST_SUBNORMAL &&\n\t\tvalue < FLOAT32_SMALLEST_SUBNORMAL\n\t) {\n\t\treturn 'float64';\n\t}\n\t// Any number which reaches this point is less than the maximum single-precision floating-point number, as floating-point format supports a limited number of decimals (e.g., (1.0+EPS)*10**15 => 1000000000000000.2, which is less than ~3.4e38)...\n\treturn 'float32';\n}\n\n\n// EXPORTS //\n\nexport default minDataType;\n"],"names":["minFloatDataType","value","PINF","NINF","isInteger","FLOAT32_MIN_SAFE_INTEGER","FLOAT32_MAX_SAFE_INTEGER","FLOAT32_SMALLEST_SUBNORMAL","minDataType","isComplexLike","re","im","isNegativeZero","INT8_MIN","INT16_MIN","INT32_MIN","UINT8_MAX","UINT16_MAX","UINT32_MAX"],"mappings":";;ozCA+CA,SAASA,EAAkBC,GAC1B,OAAKA,GAAUA,GAASA,IAAUC,GAAQD,IAAUE,EAC5C,UAEHC,EAAWH,GACVA,GAASI,GAA4BJ,GAASK,EAC3C,UAED,UAIPL,GAASM,GACTN,EAAQM,EAED,UAGD,SACR,CAmBA,SAASC,EAAaP,GACrB,MAAsB,iBAAVA,EACNQ,EAAeR,GACmB,YAAjCD,EAAkBC,EAAMS,KAAuD,YAAjCV,EAAkBC,EAAMU,IACnE,aAED,YAED,UAEHV,GAAUA,GAASA,IAAUC,GAAQD,IAAUE,EAC5C,UAEHC,EAAWH,GACA,IAAVA,GAAeW,EAAgBX,GAC5B,UAEHA,EAAQ,EACPA,GAASY,EACN,OAEHZ,GAASa,EACN,QAEHb,GAASc,EACN,QAED,UAEHd,GAASe,EACN,QAEHf,GAASgB,EACN,SAEHhB,GAASiB,EACN,SAED,UAIPjB,GAASM,GACTN,EAAQM,EAED,UAGD,SACR"}